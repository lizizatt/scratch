#!/usr/bin/env python3

import curses
import random
import sys
import time

REFERSH_RATE = 120
TRAIL_LEN = 10


def bound(a, min, max):
    if a < min:
        return min
    if a >= max:
        return max - 1
    return a

def bounce(stdscr, state):
    height, width = stdscr.getmaxyx()

    if not "init" in state:
        state["init"] = True
        state["trail"] = []
        state["i"] = int(width / 2)
        state["j"] = int(width / 2)
        state["motion"] = [1, 1]
        state["cur_color"] = 0
            
    
    trail = state["trail"]
    i = state["i"]
    j = state["j"]
    motion = state["motion"]
    cur_color = state["cur_color"]

    if i >= width - 1 or i <= 0:
        motion[0] *= -1
    if j >= height - 1 or j <= 0:
        motion[1] *= -1

    i += motion[0]
    j += motion[1]
    
    i = bound(i, 0, width)
    j = bound(j, 0, height)

    cur_color = (cur_color + 1) % n_colors
    trail.append((i, j, cur_color))
    if (len(trail) > TRAIL_LEN):
        trail = trail[1:]

    stdscr.clear()
    for (i, j, c) in trail:
        stdscr.addstr(j, i, "*", curses.color_pair(c + 1))

    state["trail"] = trail
    state["i"] = i
    state["j"] = j
    state["motion"] = motion
    state["cur_color"] = cur_color

def dodge(stdscr, state, getchs):

    SPEED = 1

    height, width = stdscr.getmaxyx()
    stdscr.clear()
    stdscr.addstr(0, 0, "blm simulator 2020", curses.color_pair(1))

    if not "init" in state:
        state["init"] = True
        state["player_pos"] = [int(width / 2), int(height / 2)]
        state["explosions"] = []
        state["next_exp_time"] = time.time() - 1

    #move
    i, j = state["player_pos"]
    if (119 in getchs): #w
        j -= SPEED

    if (97 in getchs): #a
        i -= SPEED

    if (115 in getchs): #s
        j += SPEED

    if (100 in getchs): #d
        i += SPEED

    i = min(max(i, 0), width - 1)
    j = min(max(j, 0), height - 1)

    #spawn explosions
    #process explosions
    #explosion will go off at the indicated time.time()
    #after that, it will be around for 1 second as a danger zone, anything in danger zone dies
    explosions = state["explosions"]
    next_exp_time = state["next_exp_time"]
    t = time.time()
    if t > next_exp_time:
        explosions.append([int(random.random() * width / 4 + i),
                           int(random.random() * height / 4 + j),
                           int(random.random() * 10 + 3),
                           time.time() + 1.0])
        state["next_exp_time"] = time.time() + .5 + random.random()

    for explosion in explosions:
        exp_i, exp_j, exp_rad, ep_det_t = explosion

        #remove if expired, dont draw or compute damage
        if (t > ep_det_t + 1):
            explosions.remove(explosion)
            continue

        #draw
        color_id = 2
        if (t > ep_det_t): #red if fire, yellow if telegraph
            color_id = 1
        for exp_ii in range(max(exp_i - exp_rad, 0), min(exp_i + exp_rad, width - 1)):
            for exp_jj in range(max(exp_j - exp_rad, 0), min(exp_j + exp_rad, height - 1)):
                stdscr.addstr(exp_jj, exp_ii, "*", curses.color_pair(color_id))

        #todo, compute damage


    state["explosions"] = explosions


    #draw player, overwriting explosion if in it
    #todo, clear out surrounding few pixels to make it clearer where you are in a fire
    stdscr.addstr(j, i, "*", curses.color_pair(0))

    state["player_pos"] = [i, j]

    pass

def main(stdscr):

    modes = ["bounce", "dodge"]
    mode_funcs = [bounce, dodge]
    mode_states = [{}] * len(modes)
    mode = 1

    curses.curs_set(0)
    height, width = stdscr.getmaxyx()
    stdscr.nodelay(1) # set getch() non-blocking

    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
    n_colors = 5

    bounce_state = {}
    while(True):
        #update height and width
        stdscr.refresh()
        #todo, find a way to get multiple key presses so we can do more complex input
        chs = [stdscr.getch()]
        if (32 in chs): #space
            mode = (mode + 1) % len(modes)
        mode_funcs[mode](stdscr, mode_states[mode], chs)
        time.sleep(1.0 / REFERSH_RATE)

if __name__=='__main__':
    #general globals
    height = 0
    width = 0
    n_colors = 5

    curses.wrapper(main)

